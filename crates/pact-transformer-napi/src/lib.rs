#![deny(clippy::all)]

use napi::bindgen_prelude::*;
use napi_derive::napi;
use serde::{Deserialize, Serialize};
use tree_sitter::{Node, Parser};

mod code_generator;
mod error;
mod parser;
mod types;
mod utils;

pub use error::*;
pub use types::*;

/// High-performance Pact code transformer using tree-sitter
#[napi]
pub struct PactTransformer {
    parser: Parser,
}

/// Result of transforming Pact code
#[napi(object)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TransformationResult {
    pub modules: Vec<PactModuleInfo>,
    pub code: String,
    pub types: String,
}

/// Basic module information for the result
#[napi(object)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PactModuleInfo {
    pub name: String,
    pub path: String,
}

/// Transformation options
#[napi(object)]
#[derive(Debug, Clone, Default)]
pub struct TransformOptions {
    pub debug: Option<bool>,
}

#[napi]
impl PactTransformer {
    /// Create a new PactTransformer instance
    #[napi(constructor)]
    pub fn new() -> Result<Self> {
        let mut parser = Parser::new();
        parser
            .set_language(&tree_sitter_pact::LANGUAGE.into())
            .map_err(|e| Error::new(Status::GenericFailure, format!("Failed to set language: {}", e)))?;

        Ok(PactTransformer { parser })
    }

    /// Transform Pact code into JavaScript/TypeScript code and type definitions
    #[napi]
    pub fn transform(&mut self, pact_code: String, options: Option<TransformOptions>) -> Result<TransformationResult> {
        let options = options.unwrap_or_default();
        let debug = options.debug.unwrap_or(false);

        let tree = self
            .parser
            .parse(&pact_code, None)
            .ok_or_else(|| Error::new(Status::GenericFailure, "Failed to parse Pact code".to_string()))?;

        let root = tree.root_node();

        // Check for parsing errors
        if root.has_error() {
            let errors = self.collect_errors(&root, &pact_code);
            return Err(Error::new(
                Status::InvalidArg,
                format!("Failed to parse Pact code due to syntax errors: {:?}", errors),
            ));
        }

        let modules = self.parse_modules(&root, &pact_code)?;

        let mut generated_code = String::new();
        let mut generated_types = String::new();

        // Generate code header
        generated_code.push_str("// This file was generated by the Pact Toolbox\n");
        generated_code.push_str("import { execution } from \"@pact-toolbox/client\";\n\n");

        generated_types.push_str("// This file was generated by the Pact Toolbox\n");
        generated_types.push_str("import { PactTransactionBuilder, PactExecPayload } from \"@pact-toolbox/client\";\n\n");

        let mut module_infos = Vec::new();

        for module in &modules {
            let (module_code, module_types) = code_generator::generate_module_code(module, debug);
            generated_code.push_str(&module_code);
            generated_code.push('\n');
            generated_types.push_str(&module_types);
            generated_types.push('\n');

            module_infos.push(PactModuleInfo {
                name: module.name.clone(),
                path: module.path.clone(),
            });
        }

        Ok(TransformationResult {
            modules: module_infos,
            code: generated_code,
            types: generated_types,
        })
    }

    /// Parse Pact code and return the AST structure without code generation
    #[napi]
    pub fn parse(&mut self, pact_code: String) -> Result<Vec<PactModule>> {
        let tree = self
            .parser
            .parse(&pact_code, None)
            .ok_or_else(|| Error::new(Status::GenericFailure, "Failed to parse Pact code".to_string()))?;

        let root = tree.root_node();

        if root.has_error() {
            let errors = self.collect_errors(&root, &pact_code);
            return Err(Error::new(
                Status::InvalidArg,
                format!("Failed to parse Pact code due to syntax errors: {:?}", errors),
            ));
        }

        self.parse_modules(&root, &pact_code)
    }

    fn parse_modules(&self, root: &Node, source: &str) -> Result<Vec<PactModule>> {
        let mut modules = Vec::new();
        let namespace = utils::get_namespace_of(root, source);

        let mut cursor = root.walk();
        for child in root.children(&mut cursor) {
            if child.kind() == "module" {
                let module = parser::parse_module(&child, source, namespace.as_deref())?;
                modules.push(module);
            }
        }

        Ok(modules)
    }

        fn collect_errors(&self, root: &Node, source: &str) -> Vec<ParseError> {
        let mut errors = Vec::new();

        fn collect_errors_recursive(node: &Node, source: &str, errors: &mut Vec<ParseError>) {
            if node.is_error() {
                let start_pos = node.start_position();
                let text = node.utf8_text(source.as_bytes()).unwrap_or("<invalid>");
                errors.push(ParseError {
                    message: format!("Unexpected token '{}'", text),
                    line: (start_pos.row + 1) as u32,
                    column: (start_pos.column + 1) as u32,
                });
            }

            let mut cursor = node.walk();
            for child in node.children(&mut cursor) {
                collect_errors_recursive(&child, source, errors);
            }
        }

        collect_errors_recursive(root, source, &mut errors);
        errors
    }
}

/// Create a transformer and transform Pact code in one call
#[napi]
pub fn transform_pact_code(pact_code: String, options: Option<TransformOptions>) -> Result<TransformationResult> {
    let mut transformer = PactTransformer::new()?;
    transformer.transform(pact_code, options)
}

/// Create a transformer and parse Pact code in one call
#[napi]
pub fn parse_pact_code(pact_code: String) -> Result<Vec<PactModule>> {
    let mut transformer = PactTransformer::new()?;
    transformer.parse(pact_code)
}

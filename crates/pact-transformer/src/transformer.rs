use crate::ast::*;
use crate::parser::Parser;
use napi_derive::napi;
use once_cell::sync::Lazy;
use rayon::prelude::*;
use std::sync::Mutex;

/// Global parser pool for reusing parsers
static PARSER_POOL: Lazy<Mutex<Vec<Parser>>> = Lazy::new(|| Mutex::new(Vec::new()));

/// Get a parser from the pool or create a new one
fn get_parser() -> Parser {
    let mut pool = PARSER_POOL.lock().unwrap();
    if let Some(parser) = pool.pop() { parser } else { Parser::new() }
}

/// Return a parser to the pool for reuse
fn return_parser(parser: Parser) {
    let mut pool = PARSER_POOL.lock().unwrap();
    if pool.len() < num_cpus::get() * 2 {
        pool.push(parser);
    }
    // Drop excess parsers to avoid memory bloat
}

/// Transform Pact source to JavaScript with performance optimizations
#[napi]
pub async fn transform_pact_to_js(
    source: String,
    options: Option<TransformOptions>,
) -> Result<TransformationResult, napi::Error> {
    // Use tokio's spawn_blocking for CPU-intensive work
    tokio::task::spawn_blocking(move || {
        // Get parser from pool
        let mut parser = get_parser();

        // Parse modules
        let (modules, errors) = parser.parse(&source);

        if !errors.is_empty() {
            let error_messages: Vec<String> =
                errors.iter().map(|e| format!("{}:{}: {}", e.line, e.column, e.message)).collect();
            return Err(napi::Error::from_reason(error_messages.join("\n")));
        }

        // Generate code and types in parallel using simple approach
        let (code, types) = rayon::join(
            || generate_js(&modules),
            || {
                if options.as_ref().and_then(|o| o.generate_types).unwrap_or(true) {
                    generate_types(&modules)
                } else {
                    String::new()
                }
            },
        );

        // Return parser to pool
        return_parser(parser);

        Ok(TransformationResult { modules, code, types })
    })
    .await
    .map_err(|e| napi::Error::from_reason(e.to_string()))?
}

/// JavaScript code generation with string optimizations
fn generate_js(modules: &[PactModule]) -> String {
    if modules.is_empty() {
        return "export {};".to_string();
    }

    // Pre-calculate size to avoid reallocations
    let estimated_size = modules
        .iter()
        .map(|m| 200 + m.functions.len() * 150 + m.schemas.len() * 100)
        .sum::<usize>()
        .max(1024);

    let mut output = String::with_capacity(estimated_size);

    // Header
    output.push_str("// Generated by Pact Transformer\n");
    output.push_str("/* eslint-disable */\n\n");

    // Process modules in parallel for large codebases
    if modules.len() > 1 && modules.iter().map(|m| m.functions.len()).sum::<usize>() > 10 {
        let module_parts: Vec<_> = modules.par_iter().map(generate_module_js).collect();

        for part in module_parts {
            output.push_str(&part);
            output.push('\n');
        }
    } else {
        // Sequential processing for small modules
        for module in modules {
            output.push_str(&generate_module_js(module));
            output.push('\n');
        }
    }

    output
}

/// TypeScript types generation
fn generate_types(modules: &[PactModule]) -> String {
    if modules.is_empty() {
        return "export {};".to_string();
    }

    let estimated_size = modules
        .iter()
        .map(|m| 100 + m.functions.len() * 80 + m.schemas.len() * 120)
        .sum::<usize>()
        .max(512);

    let mut output = String::with_capacity(estimated_size);

    output.push_str("// Generated TypeScript definitions\n");
    output.push_str("/* eslint-disable */\n\n");

    // Process modules in parallel for large codebases
    if modules.len() > 1 && modules.iter().map(|m| m.schemas.len()).sum::<usize>() > 5 {
        let type_parts: Vec<_> = modules.par_iter().map(generate_module_types).collect();

        for part in type_parts {
            output.push_str(&part);
            output.push('\n');
        }
    } else {
        for module in modules {
            output.push_str(&generate_module_types(module));
            output.push('\n');
        }
    }

    output
}

/// Generate JavaScript for a single module efficiently
fn generate_module_js(module: &PactModule) -> String {
    let mut output = String::with_capacity(200 + module.functions.len() * 150);

    // Module comment
    if let Some(doc) = &module.doc {
        output.push_str("/**\n * ");
        output.push_str(doc);
        output.push_str("\n */\n");
    }

    // Module namespace
    output.push_str("export const ");
    output.push_str(&module.name);
    output.push_str(" = {\n");

    // Generate functions efficiently
    for (i, function) in module.functions.iter().enumerate() {
        if i > 0 {
            output.push_str(",\n");
        }

        output.push_str("  ");
        output.push_str(&function.name);
        output.push_str(": function(");

        // Parameters
        for (j, param) in function.parameters.iter().enumerate() {
            if j > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
        }

        output.push_str(") {\n    // Function implementation\n    return null;\n  }");
    }

    output.push_str("\n};\n\n");

    // Generate type guards for schemas
    for schema in &module.schemas {
        output.push_str("export function is");
        output.push_str(&schema.name);
        output.push_str("(value: any): value is ");
        output.push_str(&schema.name);
        output.push_str(" {\n");
        output.push_str("  return typeof value === 'object' && value !== null");

        for field in &schema.fields {
            output.push_str(" && '");
            output.push_str(&field.name);
            output.push_str("' in value");
        }

        output.push_str(";\n}\n\n");
    }

    output
}

/// Generate TypeScript types for a module efficiently
fn generate_module_types(module: &PactModule) -> String {
    let mut output =
        String::with_capacity(100 + module.schemas.len() * 120 + module.functions.len() * 80);

    // Module namespace
    output.push_str("export namespace ");
    output.push_str(&module.name);
    output.push_str(" {\n");

    // Generate schema interfaces
    for schema in &module.schemas {
        if let Some(doc) = &schema.doc {
            output.push_str("  /** ");
            output.push_str(doc);
            output.push_str(" */\n");
        }

        output.push_str("  export interface ");
        output.push_str(&schema.name);
        output.push_str(" {\n");

        for field in &schema.fields {
            output.push_str("    ");
            output.push_str(&field.name);
            output.push_str(": ");
            output.push_str(map_type(&field.field_type));
            output.push_str(";\n");
        }

        output.push_str("  }\n\n");
    }

    // Generate function types
    for function in &module.functions {
        output.push_str("  export function ");
        output.push_str(&function.name);
        output.push_str("(");

        // Parameters with types
        for (i, param) in function.parameters.iter().enumerate() {
            if i > 0 {
                output.push_str(", ");
            }
            output.push_str(&param.name);
            output.push_str(": ");
            output.push_str(map_type(&param.parameter_type.as_deref().unwrap_or("any")));
        }

        output.push_str("): ");
        output.push_str(map_type(&function.return_type.as_deref().unwrap_or("any")));
        output.push_str(";\n");
    }

    output.push_str("}\n\n");
    output
}

/// Type mapping without allocations
fn map_type(pact_type: &str) -> &'static str {
    match pact_type {
        "string" => "string",
        "integer" => "number",
        "decimal" => "number",
        "bool" => "boolean",
        "time" => "Date",
        "guard" => "any",
        _ if pact_type.starts_with('[') => "any[]",
        _ if pact_type.starts_with("object") => "object",
        _ => "any",
    }
}

/// High-performance transformer with pooled parsers
#[napi]
pub struct PactTransformer;

#[napi]
impl PactTransformer {
    #[napi(constructor)]
    pub fn new() -> Self {
        Self
    }

    /// Transform Pact code with performance optimizations
    #[napi]
    pub fn transform(&self, source: String) -> Result<Vec<PactModule>, napi::Error> {
        let mut parser = get_parser();

        let (modules, errors) = parser.parse(&source);

        if !errors.is_empty() {
            let error_messages: Vec<String> =
                errors.iter().map(|e| format!("{}:{}: {}", e.line, e.column, e.message)).collect();
            return_parser(parser);
            return Err(napi::Error::from_reason(error_messages.join("\n")));
        }

        return_parser(parser);
        Ok(modules)
    }

    /// Parse method for testing - returns both modules and errors
    pub fn parse(&mut self, source: &str) -> (Vec<PactModule>, Vec<crate::error::ParseError>) {
        let mut parser = get_parser();
        let result = parser.parse(source);
        return_parser(parser);
        result
    }

    #[napi]
    pub fn get_errors(&mut self, source: String) -> Vec<crate::ErrorDetail> {
        let mut parser = get_parser();
        let (_, errors) = parser.parse(&source);
        return_parser(parser);
        errors
            .into_iter()
            .map(|e| crate::ErrorDetail {
                message: e.message,
                line: e.line as u32,
                column: e.column as u32,
            })
            .collect()
    }
}

/// Create a Pact transformer
#[napi]
pub fn create_pact_transformer() -> PactTransformer {
    PactTransformer::new()
}

/// Transformation result
#[napi(object)]
pub struct TransformationResult {
    pub modules: Vec<PactModule>,
    pub code: String,
    pub types: String,
}

/// Transform options
#[napi(object)]
pub struct TransformOptions {
    pub generate_types: Option<bool>,
    pub module_name: Option<String>,
}

/// Benchmark function to measure parser performance
#[napi]
pub fn benchmark_parser(source: String, iterations: u32) -> Result<f64, napi::Error> {
    let start = std::time::Instant::now();

    for _ in 0..iterations {
        let mut parser = get_parser();
        let (modules, errors) = parser.parse(&source);

        if !errors.is_empty() {
            return_parser(parser);
            return Err(napi::Error::from_reason("Parse error in benchmark"));
        }

        // Ensure modules are used to prevent optimization
        std::hint::black_box(modules);

        return_parser(parser);
    }

    let elapsed = start.elapsed();
    Ok(elapsed.as_secs_f64() / iterations as f64 * 1000.0) // Return average time in milliseconds
}

/// Warm up the parser pool for better initial performance
#[napi]
pub fn warm_up_parser_pool() -> Result<(), napi::Error> {
    let pool_size = num_cpus::get();
    for _ in 0..pool_size {
        let parser = Parser::new();
        return_parser(parser);
    }
    Ok(())
}

/// Reset the parser pool
#[napi]
pub fn reset_optimization_state() {
    let mut pool = PARSER_POOL.lock().unwrap();
    pool.clear();
}

impl Default for PactTransformer {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_transformer_performance() {
        let source = r#"
        (module test-module GOVERNANCE
          (defcap GOVERNANCE () true)
          (defschema test-schema
            field1: string
            field2: integer)
          (defun test-function:string (param1:string)
            "test"))
        "#;

        let transformer = PactTransformer::new();
        let result = transformer.transform(source.to_string()).unwrap();

        assert_eq!(result.len(), 1);
        assert_eq!(result[0].name, "test-module");
        assert_eq!(result[0].functions.len(), 1);
        assert_eq!(result[0].schemas.len(), 1);
    }

    #[tokio::test]
    async fn test_full_transformation() {
        let source = r#"
        (module test-module GOVERNANCE
          (defcap GOVERNANCE () true)
          (defschema test-schema
            field1: string
            field2: integer)
          (defun test-function:string (param1:string)
            "test"))
        "#;

        let result = transform_pact_to_js(
            source.to_string(),
            Some(TransformOptions { generate_types: Some(true), module_name: None }),
        )
        .await
        .unwrap();

        assert!(!result.code.is_empty());
        assert!(!result.types.is_empty());
        assert_eq!(result.modules.len(), 1);
    }
}

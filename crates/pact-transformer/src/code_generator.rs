use crate::ast::*;
use crate::plugin::get_plugin_manager;
use crate::source_map::{SourceMapGenerator, SourceMapOptions};
use crate::types::{convert_to_jsdoc, pact_type_to_typescript};
use rayon::prelude::*;
use std::fmt::Write;

pub struct CodeGenerator {
  generate_types: bool,
  source_map_gen: Option<SourceMapGenerator>,
  source_file_path: Option<String>,
}

/// Generate JavaScript code from modules
#[allow(dead_code)]
pub fn generate_js(modules: &[PactModule]) -> String {
  let mut generator = CodeGenerator::new(false);
  let (code, _, _, _) = generator.generate(modules);
  code
}

/// Generate TypeScript types from modules
#[allow(dead_code)]
pub fn generate_types(modules: &[PactModule]) -> String {
  let mut generator = CodeGenerator::new(true);
  let (_, types, _, _) = generator.generate(modules);
  types
}

impl CodeGenerator {
  pub fn new(generate_types: bool) -> Self {
    Self {
      generate_types,
      source_map_gen: None,
      source_file_path: None,
    }
  }

  pub fn new_with_source_maps(
    generate_types: bool,
    source_map_options: SourceMapOptions,
    source_content: &str,
    source_file_path: &str,
    _modules: &[PactModule],
  ) -> Self {
    let mut source_map_gen = SourceMapGenerator::new(source_map_options);

    // Use relative path for better VSCode compatibility
    let relative_source_path = std::path::Path::new(source_file_path)
      .file_name()
      .and_then(|name| name.to_str())
      .unwrap_or(source_file_path);

    source_map_gen.add_source_content(relative_source_path, source_content);

    Self {
      generate_types,
      source_map_gen: Some(source_map_gen),
      source_file_path: Some(source_file_path.to_string()),
    }
  }

  pub fn generate(
    &mut self,
    modules: &[PactModule],
  ) -> (String, String, Option<String>, Option<String>) {
    self.generate_with_filenames(modules, None, None)
  }

  pub fn generate_with_filenames(
    &mut self,
    modules: &[PactModule],
    js_filename: Option<&str>,
    ts_filename: Option<&str>,
  ) -> (String, String, Option<String>, Option<String>) {
    // Apply plugin transformations first
    let mut transformed_modules = modules.to_vec();

    let plugin_manager = get_plugin_manager();
    let manager_lock = plugin_manager.lock().unwrap();

    // Run module transformations
    if let Err(e) = manager_lock.transform_modules(&mut transformed_modules) {
      log::warn!("Plugin module transformation error: {e}");
    }

    // Run function transformations
    if let Err(e) = manager_lock.transform_functions(&mut transformed_modules) {
      log::warn!("Plugin function transformation error: {e}");
    }

    drop(manager_lock); // Release lock before generating code

    // Generate code and types in parallel
    let (code_parts, type_parts): (Vec<String>, Vec<String>) = transformed_modules
      .par_iter()
      .map(|module| {
        let code = Self::generate_module_code(module);
        let types = if self.generate_types {
          Self::generate_module_types(module)
        } else {
          String::new()
        };
        (code, types)
      })
      .unzip();

    let mut code = if code_parts.is_empty() {
      String::new()
    } else {
      format!(
                "// This file was generated by the Pact Toolbox\nimport {{ execution, continuation }} from \"@pact-toolbox/transaction\";\n\n{}",
                code_parts.join("\n\n")
            )
    };

    let mut types = if self.generate_types && !type_parts.is_empty() {
      format!(
                "// This file was generated by the Pact Toolbox\nimport {{ PactTransactionBuilder, PactExecPayload }} from \"@pact-toolbox/transaction\";\n\n{}",
                type_parts.join("\n\n")
            )
    } else {
      String::new()
    };

    // Apply plugin post-processing
    let plugin_manager = get_plugin_manager();
    let manager_lock = plugin_manager.lock().unwrap();

    if let Err(e) = manager_lock.post_generate(&mut code, &mut types, &transformed_modules) {
      log::warn!("Plugin post-generation error: {e}");
    }

    // Choose generation method based on source map availability
    if self.source_map_gen.is_some() {
      self.generate_with_source_maps(&transformed_modules, code, types, js_filename, ts_filename)
    } else {
      (code, types, None, None)
    }
  }

  fn generate_with_source_maps(
    &mut self,
    modules: &[PactModule],
    mut js_code: String,
    mut ts_types: String,
    js_filename: Option<&str>,
    ts_filename: Option<&str>,
  ) -> (String, String, Option<String>, Option<String>) {
    // If we have source maps, we need to regenerate with position tracking
    // Clear the existing code and regenerate with source map tracking
    js_code.clear();
    ts_types.clear();

    // Add import statement and track its position
    let import_line = "// This file was generated by the Pact Toolbox\nimport { execution, continuation } from \"@pact-toolbox/transaction\";\n\n";
    js_code.push_str(import_line);

    if let Some(ref mut gen) = self.source_map_gen {
      gen.advance_generated_position(import_line);
    }

    if self.generate_types {
      let types_import = "// This file was generated by the Pact Toolbox\nimport { PactTransactionBuilder, PactExecPayload } from \"@pact-toolbox/transaction\";\n\n";
      ts_types.push_str(types_import);
      // Note: Don't advance position tracker here - we'll track TypeScript separately
    }

    // Generate code for each module with source mapping
    for module in modules {
      self.generate_module_with_source_map(module, &mut js_code, &mut ts_types);
    }

    // Generate source map and declaration map
    let (source_map_json, declaration_map_json) = if let Some(ref mut gen) = self.source_map_gen {
      let source_map = if gen.get_options().generate.unwrap_or(true) {
        let js_file = js_filename.unwrap_or("generated.js");
        match gen.generate_json(js_file) {
          Ok(json) => Some(json),
          Err(e) => {
            log::warn!("Failed to generate source map JSON: {e}");
            None
          }
        }
      } else {
        None
      };

      let declaration_map =
        if self.generate_types && gen.get_options().declaration_map.unwrap_or(false) {
          let ts_file = ts_filename.unwrap_or("generated.d.ts");
          match gen.generate_declaration_map(ts_file) {
            Ok(json) => Some(json),
            Err(e) => {
              log::warn!("Failed to generate declaration map JSON: {e}");
              None
            }
          }
        } else {
          None
        };

      (source_map, declaration_map)
    } else {
      (None, None)
    };

    (js_code, ts_types, source_map_json, declaration_map_json)
  }

  fn generate_module_with_source_map(
    &mut self,
    module: &PactModule,
    js_code: &mut String,
    ts_types: &mut String,
  ) {
    // Generate schemas first with source mapping
    for schema in &module.schemas {
      self.generate_schema_with_source_map(module, schema, ts_types);
    }

    // Generate functions with source mapping
    for function in &module.functions {
      self.generate_function_with_source_map(module, function, js_code, ts_types);
    }
  }

  fn generate_schema_with_source_map(
    &mut self,
    _module: &PactModule,
    schema: &PactSchema,
    ts_types: &mut String,
  ) {
    if !self.generate_types {
      return;
    }

    // Generate schema with detailed source mapping
    // Generate JSDoc if present
    if let Some(doc) = &schema.doc {
      let doc_comment = format!("/**\n * {doc}\n */\n");
      ts_types.push_str(&doc_comment);
    }

    // Generate interface with precise source mapping
    let pascal_case_name = to_pascal_case(&schema.name);

    // Calculate the correct TypeScript line position for interface
    let ts_lines = ts_types.matches('\n').count() as u32 + 1;
    let ts_current_line = &ts_types.lines().last().unwrap_or("");
    let ts_column = ts_current_line.len() as u32;

    ts_types.push_str("export interface ");

    // Map interface name precisely at its position in TypeScript
    let interface_name_column = ts_column + "export interface ".len() as u32;

    // Direct position lookup for schema
    if let Some(ref mut gen) = self.source_map_gen {
      if let Some(ref file_path) = self.source_file_path {
        // Use relative path to match how we stored the content
        let relative_file_path = std::path::Path::new(file_path)
          .file_name()
          .and_then(|name| name.to_str())
          .unwrap_or(file_path);

        if let Some(source_content) = gen.get_source_content(relative_file_path) {
          let search_text = format!("defschema {}", schema.name);
          let lines: Vec<&str> = source_content.lines().collect();

          for (line_idx, line) in lines.iter().enumerate() {
            if let Some(col_idx) = line.find(&search_text) {
              let source_line = (line_idx + 1) as u32;
              let source_column = col_idx as u32;

              // Convert to relative path for VSCode compatibility
              let relative_file_path = std::path::Path::new(file_path)
                .file_name()
                .and_then(|name| name.to_str())
                .unwrap_or(file_path);

              gen.add_mapping(
                ts_lines,
                interface_name_column,
                relative_file_path,
                source_line,
                source_column,
                Some(&pascal_case_name),
              );
              break;
            }
          }
        }
      }
    }

    let interface_rest = format!("{pascal_case_name} {{\n");
    ts_types.push_str(&interface_rest);

    // Generate fields
    for field in &schema.fields {
      let ts_type = crate::types::pact_type_to_typescript(&field.field_type);
      let camel_case_field = to_camel_case(&field.name);
      let field_line = format!("  {camel_case_field}: {ts_type};\n");
      ts_types.push_str(&field_line);
    }

    let interface_end = "}\n\n";
    ts_types.push_str(interface_end);
  }

  fn generate_function_with_source_map(
    &mut self,
    module: &PactModule,
    function: &PactFunction,
    js_code: &mut String,
    ts_types: &mut String,
  ) {
    eprintln!("GENERATE_FUNCTION_WITH_SOURCE_MAP: {}", function.name);
    let camel_case_name = to_camel_case(&function.name);

    // Generate JSDoc for JavaScript
    if let Some(doc) = &function.doc {
      let doc_comment = format!("/**\n * {doc}\n */\n");
      js_code.push_str(&doc_comment);
      if let Some(ref mut gen) = self.source_map_gen {
        gen.advance_generated_position(&doc_comment);
      }
    }

    // Generate function parameters
    let params = function
      .parameters
      .iter()
      .map(|p| &p.name)
      .cloned()
      .collect::<Vec<_>>()
      .join(", ");

    // Generate JavaScript function with detailed source mapping
    js_code.push_str("export function ");
    if let Some(ref mut gen) = self.source_map_gen {
      gen.advance_generated_position("export function ");
    }

    // Old mapping code removed - using direct lookup in TypeScript generation instead

    let func_rest = format!("{camel_case_name}({params}) {{\n");
    js_code.push_str(&func_rest);
    if let Some(ref mut gen) = self.source_map_gen {
      gen.advance_generated_position(&func_rest);
    }

    // Create Pact command string with proper module reference including namespace
    let module_ref = if let Some(namespace) = &module.namespace {
      format!("{}.{}", namespace, module.name)
    } else {
      module.name.to_string()
    };
    let mut pact_cmd = format!("({}.{}", module_ref, function.name);

    // Add parameters with JSON.stringify for proper escaping
    for param in &function.parameters {
      let param_ref = format!(" ${{JSON.stringify({})}}", param.name);
      pact_cmd.push_str(&param_ref);
    }
    pact_cmd.push(')');

    // Use execution for defuns, continuation for defpacts
    let builder = if function.is_defun {
      "execution"
    } else {
      "continuation"
    };
    let return_line = format!("    return {builder}(`{pact_cmd}`);\n");
    js_code.push_str(&return_line);
    if let Some(ref mut gen) = self.source_map_gen {
      gen.advance_generated_position(&return_line);
    }

    let func_end = "}\n\n";
    js_code.push_str(func_end);
    if let Some(ref mut gen) = self.source_map_gen {
      gen.advance_generated_position(func_end);
    }

    // Generate TypeScript declaration if requested
    eprintln!(
      "generate_types: {}, source_map_gen: {}",
      self.generate_types,
      self.source_map_gen.is_some()
    );
    if self.generate_types {
      if let Some(doc) = &function.doc {
        let doc_comment = format!("/**\n * {doc}\n */\n");
        ts_types.push_str(&doc_comment);
      }

      // Generate parameter types with camelCase names
      let param_types = if function.parameters.is_empty() {
        String::new()
      } else {
        function
          .parameters
          .iter()
          .map(|p| {
            let ts_type = p.parameter_type.as_ref().map_or_else(
              || "any".to_string(),
              |t| crate::types::pact_type_to_typescript(t),
            );
            let camel_case_param = to_camel_case(&p.name);
            format!("{camel_case_param}: {ts_type}")
          })
          .collect::<Vec<_>>()
          .join(", ")
      };

      // Generate return type
      let return_type = function.return_type.as_ref().map_or_else(
        || "unknown".to_string(),
        |t| crate::types::pact_type_to_typescript(t),
      );

      // Generate TypeScript declaration with precise source mapping
      // Calculate the correct TypeScript line position
      let ts_lines = ts_types.matches('\n').count() as u32 + 1;
      let ts_current_line = &ts_types.lines().last().unwrap_or("");
      let ts_column = ts_current_line.len() as u32;

      ts_types.push_str("export function ");

      // Map function name precisely at its position in TypeScript
      let function_name_column = ts_column + "export function ".len() as u32;

      // Direct position lookup to avoid any state issues
      if let Some(ref mut gen) = self.source_map_gen {
        if let Some(ref file_path) = self.source_file_path {
          // Use relative path to match how we stored the content
          let relative_file_path = std::path::Path::new(file_path)
            .file_name()
            .and_then(|name| name.to_str())
            .unwrap_or(file_path);

          // Look up position directly using the exact function name
          if let Some(source_content) = gen.get_source_content(relative_file_path) {
            let search_text = format!("defun {}", function.name);
            let lines: Vec<&str> = source_content.lines().collect();

            for (line_idx, line) in lines.iter().enumerate() {
              if let Some(col_idx) = line.find(&search_text) {
                let source_line = (line_idx + 1) as u32;
                let source_column = col_idx as u32;

                // Debug output to verify our code is running
                eprintln!(
                  "DIRECT LOOKUP: {camel_case_name} -> {source_line}:{source_column} ({search_text}) [GEN: {ts_lines}:{function_name_column}]"
                );

                // Convert to relative path for VSCode compatibility
                let relative_file_path = std::path::Path::new(file_path)
                  .file_name()
                  .and_then(|name| name.to_str())
                  .unwrap_or(file_path);

                gen.add_mapping(
                  ts_lines,
                  function_name_column,
                  relative_file_path,
                  source_line,
                  source_column,
                  Some(&camel_case_name),
                );
                break;
              }
            }
          }
        }
      }

      let ts_rest = format!(
        "{camel_case_name}({param_types}): PactTransactionBuilder<PactExecPayload, {return_type}>;\n"
      );
      ts_types.push_str(&ts_rest);
    }
  }

  fn generate_module_code(module: &PactModule) -> String {
    let mut code = String::with_capacity(4096);

    // Generate functions as standalone exports
    let function_codes: Vec<String> = module
      .functions
      .par_iter()
      .map(|func| Self::generate_function_code(func, module))
      .collect();

    for func_code in function_codes {
      code.push_str(&func_code);
      code.push('\n');
    }

    code
  }

  fn generate_function_code(function: &PactFunction, module: &PactModule) -> String {
    let mut code = String::with_capacity(1024);

    // Generate JSDoc
    if let Some(doc) = &function.doc {
      code.push_str(&convert_to_jsdoc(Some(doc)));
    }

    // Convert function name to camelCase
    let camel_case_name = to_camel_case(&function.name);

    // Generate function parameters
    let params = function
      .parameters
      .iter()
      .map(|p| &p.name)
      .cloned()
      .collect::<Vec<_>>()
      .join(", ");

    // Generate function
    writeln!(&mut code, "export function {camel_case_name}({params}) {{").unwrap();

    // Create Pact command string with proper module reference including namespace
    let module_ref = if let Some(namespace) = &module.namespace {
      format!("{}.{}", namespace, module.name)
    } else {
      module.name.to_string()
    };
    let mut pact_cmd = format!("({}.{}", module_ref, function.name);

    // Add parameters with JSON.stringify for proper escaping
    for param in &function.parameters {
      write!(&mut pact_cmd, " ${{JSON.stringify({})}}", param.name).unwrap();
    }
    pact_cmd.push(')');

    // Use execution for defuns, continuation for defpacts
    let builder = if function.is_defun {
      "execution"
    } else {
      "continuation"
    };

    writeln!(&mut code, "    return {builder}(`{pact_cmd}`);").unwrap();
    writeln!(&mut code, "}}").unwrap();

    code
  }

  fn generate_module_types(module: &PactModule) -> String {
    let mut types = String::with_capacity(4096);

    // Generate schema types first
    for schema in &module.schemas {
      types.push_str(&Self::generate_schema_type(schema));
    }

    // Generate function types
    for function in &module.functions {
      types.push_str(&Self::generate_function_type(function));
    }

    types
  }

  fn generate_schema_type(schema: &PactSchema) -> String {
    let mut types = String::with_capacity(512);

    if let Some(doc) = &schema.doc {
      types.push_str(&convert_to_jsdoc(Some(doc)));
    }

    // Use PascalCase for interface names
    let pascal_case_name = to_pascal_case(&schema.name);
    writeln!(&mut types, "export interface {pascal_case_name} {{").unwrap();

    for field in &schema.fields {
      let ts_type = pact_type_to_typescript(&field.field_type);
      // Use camelCase for field names
      let camel_case_field = to_camel_case(&field.name);
      writeln!(&mut types, "  {camel_case_field}: {ts_type};").unwrap();
    }

    writeln!(&mut types, "}}").unwrap();
    writeln!(&mut types).unwrap();

    types
  }

  fn generate_function_type(function: &PactFunction) -> String {
    let mut types = String::with_capacity(256);

    if let Some(doc) = &function.doc {
      types.push_str(&convert_to_jsdoc(Some(doc)));
    }

    // Convert function name to camelCase
    let camel_case_name = to_camel_case(&function.name);

    // Generate parameter types with camelCase names
    let param_types = if function.parameters.is_empty() {
      String::new()
    } else {
      function
        .parameters
        .iter()
        .map(|p| {
          let ts_type = p
            .parameter_type
            .as_ref()
            .map_or_else(|| "any".to_string(), |t| pact_type_to_typescript(t));
          let camel_case_param = to_camel_case(&p.name);
          format!("{camel_case_param}: {ts_type}")
        })
        .collect::<Vec<_>>()
        .join(", ")
    };

    // Generate return type - map Pact types to TypeScript and handle special cases
    let return_type = function
      .return_type
      .as_ref()
      .map_or_else(|| "unknown".to_string(), |t| pact_type_to_typescript(t));

    writeln!(
      &mut types,
      "export function {camel_case_name}({param_types}): PactTransactionBuilder<PactExecPayload, {return_type}>;"
    )
    .unwrap();

    types
  }
}

/// Convert `snake_case` or kebab-case to camelCase
fn to_camel_case(s: &str) -> String {
  let mut result = String::new();
  let mut capitalize_next = false;

  for (i, c) in s.chars().enumerate() {
    if c == '-' || c == '_' {
      capitalize_next = true;
    } else if i == 0 {
      result.push(c.to_lowercase().next().unwrap_or(c));
    } else if capitalize_next {
      result.push(c.to_uppercase().next().unwrap_or(c));
      capitalize_next = false;
    } else {
      result.push(c);
    }
  }

  result
}

/// Convert `snake_case` or kebab-case to `PascalCase`
fn to_pascal_case(s: &str) -> String {
  let mut result = String::new();
  let mut capitalize_next = true;

  for c in s.chars() {
    if c == '-' || c == '_' {
      capitalize_next = true;
    } else if capitalize_next {
      result.push(c.to_uppercase().next().unwrap_or(c));
      capitalize_next = false;
    } else {
      result.push(c);
    }
  }

  result
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_generate_empty_module() {
    let module = PactModule::new("test".to_string(), "governance".to_string());
    let mut generator = CodeGenerator::new(false);
    let (code, _, _, _) = generator.generate(&[module]);

    assert!(code.contains("import { execution, continuation }"));
  }

  #[test]
  fn test_generate_function() {
    let mut module = PactModule::new("todos".to_string(), "governance".to_string());
    let function = PactFunction {
      name: "create-todo".to_string(),
      doc: Some("Create new todo with ID and TITLE.".to_string()),
      parameters: vec![
        PactParameter {
          name: "id".to_string(),
          parameter_type: Some("string".to_string()),
        },
        PactParameter {
          name: "title".to_string(),
          parameter_type: Some("string".to_string()),
        },
      ],
      return_type: Some("string".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(true);
    let (code, types, _, _) = generator.generate(&[module]);

    // Check JavaScript generation
    assert!(code.contains("export function createTodo(id, title) {"));
    assert!(code.contains(
      "return execution(`(todos.create-todo ${JSON.stringify(id)} ${JSON.stringify(title)})`);"
    ));

    // Check TypeScript generation
    assert!(types.contains("export function createTodo(id: string, title: string): PactTransactionBuilder<PactExecPayload, string>;"));
  }

  #[test]
  fn test_namespace_inclusion() {
    let mut module = PactModule::with_namespace(
      "todos".to_string(),
      Some("free".to_string()),
      "governance".to_string(),
    );

    let function = PactFunction {
      name: "get-todos".to_string(),
      doc: Some("Get all todos".to_string()),
      parameters: vec![],
      return_type: Some("[object{todo}]".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(false);
    let (code, _, _, _) = generator.generate(&[module]);

    assert!(code.contains("return execution(`(free.todos.get-todos)`);"));
    assert!(code.contains("export function getTodos() {"));
  }

  #[test]
  fn test_module_without_namespace() {
    let mut module = PactModule::new("utils".to_string(), "governance".to_string());

    let function = PactFunction {
      name: "helper-func".to_string(),
      doc: None,
      parameters: vec![PactParameter {
        name: "value".to_string(),
        parameter_type: Some("string".to_string()),
      }],
      return_type: Some("bool".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(false);
    let (code, _, _, _) = generator.generate(&[module]);

    assert!(code.contains("return execution(`(utils.helper-func ${JSON.stringify(value)})`);"));
    assert!(code.contains("export function helperFunc(value) {"));
  }

  #[test]
  fn test_defpact_uses_continuation() {
    let mut module = PactModule::new("transfers".to_string(), "governance".to_string());

    let defpact = PactFunction {
      name: "cross-chain-transfer".to_string(),
      doc: Some("Transfer tokens across chains".to_string()),
      parameters: vec![
        PactParameter {
          name: "from".to_string(),
          parameter_type: Some("string".to_string()),
        },
        PactParameter {
          name: "to".to_string(),
          parameter_type: Some("string".to_string()),
        },
      ],
      return_type: Some("string".to_string()),
      body: "...".to_string(),
      is_defun: false, // This is a defpact
    };
    module.add_function(defpact);

    let mut generator = CodeGenerator::new(false);
    let (code, _, _, _) = generator.generate(&[module]);

    assert!(code.contains("return continuation(`(transfers.cross-chain-transfer"));
    assert!(code.contains("export function crossChainTransfer(from, to) {"));
  }

  #[test]
  fn test_function_with_no_parameters() {
    let mut module = PactModule::new("counter".to_string(), "governance".to_string());

    let function = PactFunction {
      name: "get-count".to_string(),
      doc: Some("Get current count".to_string()),
      parameters: vec![],
      return_type: Some("integer".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(true);
    let (code, types, _, _) = generator.generate(&[module]);

    assert!(code.contains("export function getCount() {"));
    assert!(code.contains("return execution(`(counter.get-count)`);"));
    assert!(types
      .contains("export function getCount(): PactTransactionBuilder<PactExecPayload, number>;"));
  }

  #[test]
  fn test_function_with_many_parameters() {
    let mut module = PactModule::new("user".to_string(), "governance".to_string());

    let function = PactFunction {
      name: "create-user-profile".to_string(),
      doc: Some("Create a user profile".to_string()),
      parameters: vec![
        PactParameter {
          name: "user-id".to_string(),
          parameter_type: Some("string".to_string()),
        },
        PactParameter {
          name: "first-name".to_string(),
          parameter_type: Some("string".to_string()),
        },
        PactParameter {
          name: "last-name".to_string(),
          parameter_type: Some("string".to_string()),
        },
        PactParameter {
          name: "email".to_string(),
          parameter_type: Some("string".to_string()),
        },
        PactParameter {
          name: "age".to_string(),
          parameter_type: Some("integer".to_string()),
        },
      ],
      return_type: Some("string".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(true);
    let (code, types, _, _) = generator.generate(&[module]);

    assert!(code
      .contains("export function createUserProfile(user-id, first-name, last-name, email, age) {"));
    assert!(code.contains("${JSON.stringify(user-id)} ${JSON.stringify(first-name)} ${JSON.stringify(last-name)} ${JSON.stringify(email)} ${JSON.stringify(age)}"));
    assert!(types
      .contains("userId: string, firstName: string, lastName: string, email: string, age: number"));
  }

  #[test]
  fn test_schema_generation() {
    let mut module = PactModule::new("users".to_string(), "governance".to_string());

    let schema = PactSchema {
      name: "user-profile".to_string(),
      doc: Some("User profile schema".to_string()),
      fields: vec![
        SchemaField {
          name: "user-id".to_string(),
          field_type: "string".to_string(),
        },
        SchemaField {
          name: "email-address".to_string(),
          field_type: "string".to_string(),
        },
        SchemaField {
          name: "is-active".to_string(),
          field_type: "bool".to_string(),
        },
        SchemaField {
          name: "signup-date".to_string(),
          field_type: "time".to_string(),
        },
      ],
    };
    module.add_schema(schema);

    let mut generator = CodeGenerator::new(true);
    let (_, types, _, _) = generator.generate(&[module]);

    assert!(types.contains("export interface UserProfile {"));
    assert!(types.contains("userId: string;"));
    assert!(types.contains("emailAddress: string;"));
    assert!(types.contains("isActive: boolean;"));
    assert!(types.contains("signupDate: Date;"));
    assert!(types.contains("* User profile schema"));
  }

  #[test]
  fn test_multiple_modules() {
    let mut module1 = PactModule::with_namespace(
      "todos".to_string(),
      Some("free".to_string()),
      "governance".to_string(),
    );

    let function1 = PactFunction {
      name: "create-todo".to_string(),
      doc: None,
      parameters: vec![PactParameter {
        name: "id".to_string(),
        parameter_type: Some("string".to_string()),
      }],
      return_type: Some("string".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module1.add_function(function1);

    let mut module2 = PactModule::new("counters".to_string(), "governance".to_string());

    let function2 = PactFunction {
      name: "increment".to_string(),
      doc: None,
      parameters: vec![],
      return_type: Some("integer".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module2.add_function(function2);

    let mut generator = CodeGenerator::new(false);
    let (code, _, _, _) = generator.generate(&[module1, module2]);

    assert!(code.contains("export function createTodo(id) {"));
    assert!(code.contains("return execution(`(free.todos.create-todo ${JSON.stringify(id)})`);"));
    assert!(code.contains("export function increment() {"));
    assert!(code.contains("return execution(`(counters.increment)`);"));
  }

  #[test]
  fn test_complex_return_types() {
    let mut module = PactModule::new("data".to_string(), "governance".to_string());

    let functions = vec![
      PactFunction {
        name: "get-item".to_string(),
        doc: None,
        parameters: vec![],
        return_type: Some("object{item}".to_string()),
        body: "...".to_string(),
        is_defun: true,
      },
      PactFunction {
        name: "get-items".to_string(),
        doc: None,
        parameters: vec![],
        return_type: Some("[object{item}]".to_string()),
        body: "...".to_string(),
        is_defun: true,
      },
      PactFunction {
        name: "get-strings".to_string(),
        doc: None,
        parameters: vec![],
        return_type: Some("[string]".to_string()),
        body: "...".to_string(),
        is_defun: true,
      },
      PactFunction {
        name: "get-guard".to_string(),
        doc: None,
        parameters: vec![],
        return_type: Some("guard".to_string()),
        body: "...".to_string(),
        is_defun: true,
      },
    ];

    for func in functions {
      module.add_function(func);
    }

    let mut generator = CodeGenerator::new(true);
    let (_, types, _, _) = generator.generate(&[module]);

    assert!(types.contains("PactTransactionBuilder<PactExecPayload, Item>;"));
    assert!(types.contains("PactTransactionBuilder<PactExecPayload, Item[]>;"));
    assert!(types.contains("PactTransactionBuilder<PactExecPayload, string[]>;"));
    assert!(types.contains("PactTransactionBuilder<PactExecPayload, object>;"));
  }

  #[test]
  fn test_jsdoc_generation() {
    let mut module = PactModule::new("docs".to_string(), "governance".to_string());

    let function = PactFunction {
      name: "documented-function".to_string(),
      doc: Some("This is a well documented function\nthat spans multiple lines".to_string()),
      parameters: vec![PactParameter {
        name: "param".to_string(),
        parameter_type: Some("string".to_string()),
      }],
      return_type: Some("string".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(false);
    let (code, _, _, _) = generator.generate(&[module]);

    assert!(code.contains("/**"));
    assert!(code.contains("* This is a well documented function"));
    assert!(code.contains("*/"));
    assert!(code.contains("export function documentedFunction(param) {"));
  }

  #[test]
  fn test_case_conversion_edge_cases() {
    // Test camelCase conversion
    assert_eq!(to_camel_case(""), "");
    assert_eq!(to_camel_case("a"), "a");
    assert_eq!(to_camel_case("A"), "a");
    assert_eq!(to_camel_case("a-b"), "aB");
    assert_eq!(to_camel_case("a_b"), "aB");
    assert_eq!(to_camel_case("a-b-c"), "aBC");
    assert_eq!(to_camel_case("a_b_c"), "aBC");
    assert_eq!(to_camel_case("already-camelCase"), "alreadyCamelCase");
    assert_eq!(to_camel_case("kebab-case-long-name"), "kebabCaseLongName");
    assert_eq!(to_camel_case("snake_case_long_name"), "snakeCaseLongName");

    // Test PascalCase conversion
    assert_eq!(to_pascal_case(""), "");
    assert_eq!(to_pascal_case("a"), "A");
    assert_eq!(to_pascal_case("A"), "A");
    assert_eq!(to_pascal_case("a-b"), "AB");
    assert_eq!(to_pascal_case("a_b"), "AB");
    assert_eq!(to_pascal_case("a-b-c"), "ABC");
    assert_eq!(to_pascal_case("a_b_c"), "ABC");
    assert_eq!(to_pascal_case("kebab-case-interface"), "KebabCaseInterface");
    assert_eq!(to_pascal_case("snake_case_interface"), "SnakeCaseInterface");
  }

  #[test]
  fn test_special_characters_in_names() {
    // Test handling of special characters that might appear in Pact
    assert_eq!(to_camel_case("get-balance*"), "getBalance*");
    assert_eq!(to_camel_case("validate?"), "validate?");
    assert_eq!(to_camel_case("format-data!"), "formatData!");

    assert_eq!(to_pascal_case("user-data*"), "UserData*");
    assert_eq!(to_pascal_case("validation?"), "Validation?");
    assert_eq!(to_pascal_case("action!"), "Action!");
  }

  #[test]
  fn test_parameter_type_handling() {
    let mut module = PactModule::new("types".to_string(), "governance".to_string());

    let function = PactFunction {
      name: "test-types".to_string(),
      doc: None,
      parameters: vec![
        PactParameter {
          name: "no-type".to_string(),
          parameter_type: None, // Test missing type
        },
        PactParameter {
          name: "with-type".to_string(),
          parameter_type: Some("string".to_string()),
        },
      ],
      return_type: Some("bool".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(true);
    let (_, types, _, _) = generator.generate(&[module]);

    assert!(types.contains("noType: any"));
    assert!(types.contains("withType: string"));
  }

  #[test]
  fn test_no_types_generation() {
    let mut module = PactModule::new("simple".to_string(), "governance".to_string());

    let function = PactFunction {
      name: "simple-func".to_string(),
      doc: None,
      parameters: vec![],
      return_type: Some("string".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(false); // No types
    let (code, types, _, _) = generator.generate(&[module]);

    assert!(code.contains("export function simpleFunc() {"));
    assert!(types.is_empty());
  }

  #[test]
  fn test_empty_modules_list() {
    let mut generator = CodeGenerator::new(true);
    let (code, types, _, _) = generator.generate(&[]);

    assert!(code.is_empty());
    assert!(types.is_empty());
  }
}

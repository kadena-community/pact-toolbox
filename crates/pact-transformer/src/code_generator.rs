use crate::ast::*;
use crate::plugin::get_plugin_manager;
use crate::types::{convert_to_jsdoc, pact_type_to_typescript};
use rayon::prelude::*;
use std::fmt::Write;

pub struct CodeGenerator {
  generate_types: bool,
}

/// Generate JavaScript code from modules
#[allow(dead_code)]
pub fn generate_js(modules: &[PactModule]) -> String {
  let mut generator = CodeGenerator::new(false);
  let (code, _) = generator.generate(modules);
  code
}

/// Generate TypeScript types from modules
#[allow(dead_code)]
pub fn generate_types(modules: &[PactModule]) -> String {
  let mut generator = CodeGenerator::new(true);
  let (_, types) = generator.generate(modules);
  types
}

impl CodeGenerator {
  pub fn new(generate_types: bool) -> Self {
    Self { generate_types }
  }

  pub fn generate(&mut self, modules: &[PactModule]) -> (String, String) {
    // Apply plugin transformations first
    let mut transformed_modules = modules.to_vec();

    let plugin_manager = get_plugin_manager();
    let manager_lock = plugin_manager.lock().unwrap();

    // Run module transformations
    if let Err(e) = manager_lock.transform_modules(&mut transformed_modules) {
      log::warn!("Plugin module transformation error: {}", e);
    }

    // Run function transformations
    if let Err(e) = manager_lock.transform_functions(&mut transformed_modules) {
      log::warn!("Plugin function transformation error: {}", e);
    }

    drop(manager_lock); // Release lock before generating code

    // Generate code and types in parallel
    let (code_parts, type_parts): (Vec<String>, Vec<String>) = transformed_modules
      .par_iter()
      .map(|module| {
        let code = self.generate_module_code(module);
        let types = if self.generate_types {
          self.generate_module_types(module)
        } else {
          String::new()
        };
        (code, types)
      })
      .unzip();

    let mut code = if code_parts.is_empty() {
      String::new()
    } else {
      format!(
                "// This file was generated by the Pact Toolbox\nimport {{ execution, continuation }} from \"@pact-toolbox/transaction\";\n\n{}",
                code_parts.join("\n\n")
            )
    };

    let mut types = if self.generate_types && !type_parts.is_empty() {
      format!(
                "// This file was generated by the Pact Toolbox\nimport {{ PactTransactionBuilder, PactExecPayload }} from \"@pact-toolbox/transaction\";\n\n{}",
                type_parts.join("\n\n")
            )
    } else {
      String::new()
    };

    // Apply plugin post-processing
    let plugin_manager = get_plugin_manager();
    let manager_lock = plugin_manager.lock().unwrap();

    if let Err(e) = manager_lock.post_generate(&mut code, &mut types, &transformed_modules) {
      log::warn!("Plugin post-generation error: {}", e);
    }

    (code, types)
  }

  fn generate_module_code(&self, module: &PactModule) -> String {
    let mut code = String::with_capacity(4096);

    // Generate functions as standalone exports
    let function_codes: Vec<String> = module
      .functions
      .par_iter()
      .map(|func| Self::generate_function_code(func, module))
      .collect();

    for func_code in function_codes {
      code.push_str(&func_code);
      code.push('\n');
    }

    code
  }

  fn generate_function_code(function: &PactFunction, module: &PactModule) -> String {
    let mut code = String::with_capacity(1024);

    // Generate JSDoc
    if let Some(doc) = &function.doc {
      code.push_str(&convert_to_jsdoc(Some(doc)));
    }

    // Convert function name to camelCase
    let camel_case_name = to_camel_case(&function.name);

    // Generate function parameters
    let params = function
      .parameters
      .iter()
      .map(|p| &p.name)
      .cloned()
      .collect::<Vec<_>>()
      .join(", ");

    // Generate function
    writeln!(
      &mut code,
      "export function {}({}) {{",
      camel_case_name, params
    )
    .unwrap();

    // Create Pact command string with proper module reference including namespace
    let module_ref = if let Some(namespace) = &module.namespace {
      format!("{}.{}", namespace, module.name)
    } else {
      module.name.to_string()
    };
    let mut pact_cmd = format!("({}.{}", module_ref, function.name);

    // Add parameters with JSON.stringify for proper escaping
    for param in &function.parameters {
      write!(&mut pact_cmd, " ${{JSON.stringify({})}}", param.name).unwrap();
    }
    pact_cmd.push(')');

    // Use execution for defuns, continuation for defpacts
    let builder = if function.is_defun {
      "execution"
    } else {
      "continuation"
    };

    writeln!(&mut code, "    return {}(`{}`);", builder, pact_cmd).unwrap();
    writeln!(&mut code, "}}").unwrap();

    code
  }

  fn generate_module_types(&self, module: &PactModule) -> String {
    let mut types = String::with_capacity(4096);

    // Generate schema types first
    for schema in &module.schemas {
      types.push_str(&Self::generate_schema_type(schema));
    }

    // Generate function types
    for function in &module.functions {
      types.push_str(&Self::generate_function_type(function));
    }

    types
  }

  fn generate_schema_type(schema: &PactSchema) -> String {
    let mut types = String::with_capacity(512);

    if let Some(doc) = &schema.doc {
      types.push_str(&convert_to_jsdoc(Some(doc)));
    }

    // Use PascalCase for interface names
    let pascal_case_name = to_pascal_case(&schema.name);
    writeln!(&mut types, "export interface {} {{", pascal_case_name).unwrap();

    for field in &schema.fields {
      let ts_type = pact_type_to_typescript(&field.field_type);
      // Use camelCase for field names
      let camel_case_field = to_camel_case(&field.name);
      writeln!(&mut types, "  {}: {};", camel_case_field, ts_type).unwrap();
    }

    writeln!(&mut types, "}}").unwrap();
    writeln!(&mut types).unwrap();

    types
  }

  fn generate_function_type(function: &PactFunction) -> String {
    let mut types = String::with_capacity(256);

    if let Some(doc) = &function.doc {
      types.push_str(&convert_to_jsdoc(Some(doc)));
    }

    // Convert function name to camelCase
    let camel_case_name = to_camel_case(&function.name);

    // Generate parameter types with camelCase names
    let param_types = if function.parameters.is_empty() {
      String::new()
    } else {
      function
        .parameters
        .iter()
        .map(|p| {
          let ts_type = p
            .parameter_type
            .as_ref()
            .map(|t| pact_type_to_typescript(t))
            .unwrap_or_else(|| "any".to_string());
          let camel_case_param = to_camel_case(&p.name);
          format!("{}: {}", camel_case_param, ts_type)
        })
        .collect::<Vec<_>>()
        .join(", ")
    };

    // Generate return type - map Pact types to TypeScript and handle special cases
    let return_type = function
      .return_type
      .as_ref()
      .map(|t| pact_type_to_typescript(t))
      .unwrap_or_else(|| "unknown".to_string());

    writeln!(
      &mut types,
      "export function {}({}): PactTransactionBuilder<PactExecPayload, {}>;",
      camel_case_name, param_types, return_type
    )
    .unwrap();

    types
  }
}

/// Convert snake_case or kebab-case to camelCase
fn to_camel_case(s: &str) -> String {
  let mut result = String::new();
  let mut capitalize_next = false;

  for (i, c) in s.chars().enumerate() {
    if c == '-' || c == '_' {
      capitalize_next = true;
    } else if i == 0 {
      result.push(c.to_lowercase().next().unwrap_or(c));
    } else if capitalize_next {
      result.push(c.to_uppercase().next().unwrap_or(c));
      capitalize_next = false;
    } else {
      result.push(c);
    }
  }

  result
}

/// Convert snake_case or kebab-case to PascalCase
fn to_pascal_case(s: &str) -> String {
  let mut result = String::new();
  let mut capitalize_next = true;

  for c in s.chars() {
    if c == '-' || c == '_' {
      capitalize_next = true;
    } else if capitalize_next {
      result.push(c.to_uppercase().next().unwrap_or(c));
      capitalize_next = false;
    } else {
      result.push(c);
    }
  }

  result
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_generate_empty_module() {
    let module = PactModule::new("test".to_string(), "governance".to_string());
    let mut generator = CodeGenerator::new(false);
    let (code, _) = generator.generate(&[module]);

    assert!(code.contains("import { execution, continuation }"));
  }

  #[test]
  fn test_generate_function() {
    let mut module = PactModule::new("todos".to_string(), "governance".to_string());
    let function = PactFunction {
      name: "create-todo".to_string(),
      doc: Some("Create new todo with ID and TITLE.".to_string()),
      parameters: vec![
        PactParameter {
          name: "id".to_string(),
          parameter_type: Some("string".to_string()),
        },
        PactParameter {
          name: "title".to_string(),
          parameter_type: Some("string".to_string()),
        },
      ],
      return_type: Some("string".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(true);
    let (code, types) = generator.generate(&[module]);

    // Check JavaScript generation
    assert!(code.contains("export function createTodo(id, title) {"));
    assert!(code.contains(
      "return execution(`(todos.create-todo ${JSON.stringify(id)} ${JSON.stringify(title)})`);"
    ));

    // Check TypeScript generation
    assert!(types.contains("export function createTodo(id: string, title: string): PactTransactionBuilder<PactExecPayload, string>;"));
  }

  #[test]
  fn test_namespace_inclusion() {
    let mut module = PactModule::with_namespace(
      "todos".to_string(),
      Some("free".to_string()),
      "governance".to_string(),
    );

    let function = PactFunction {
      name: "get-todos".to_string(),
      doc: Some("Get all todos".to_string()),
      parameters: vec![],
      return_type: Some("[object{todo}]".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(false);
    let (code, _) = generator.generate(&[module]);

    assert!(code.contains("return execution(`(free.todos.get-todos)`);"));
    assert!(code.contains("export function getTodos() {"));
  }

  #[test]
  fn test_module_without_namespace() {
    let mut module = PactModule::new("utils".to_string(), "governance".to_string());

    let function = PactFunction {
      name: "helper-func".to_string(),
      doc: None,
      parameters: vec![PactParameter {
        name: "value".to_string(),
        parameter_type: Some("string".to_string()),
      }],
      return_type: Some("bool".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(false);
    let (code, _) = generator.generate(&[module]);

    assert!(code.contains("return execution(`(utils.helper-func ${JSON.stringify(value)})`);"));
    assert!(code.contains("export function helperFunc(value) {"));
  }

  #[test]
  fn test_defpact_uses_continuation() {
    let mut module = PactModule::new("transfers".to_string(), "governance".to_string());

    let defpact = PactFunction {
      name: "cross-chain-transfer".to_string(),
      doc: Some("Transfer tokens across chains".to_string()),
      parameters: vec![
        PactParameter {
          name: "from".to_string(),
          parameter_type: Some("string".to_string()),
        },
        PactParameter {
          name: "to".to_string(),
          parameter_type: Some("string".to_string()),
        },
      ],
      return_type: Some("string".to_string()),
      body: "...".to_string(),
      is_defun: false, // This is a defpact
    };
    module.add_function(defpact);

    let mut generator = CodeGenerator::new(false);
    let (code, _) = generator.generate(&[module]);

    assert!(code.contains("return continuation(`(transfers.cross-chain-transfer"));
    assert!(code.contains("export function crossChainTransfer(from, to) {"));
  }

  #[test]
  fn test_function_with_no_parameters() {
    let mut module = PactModule::new("counter".to_string(), "governance".to_string());

    let function = PactFunction {
      name: "get-count".to_string(),
      doc: Some("Get current count".to_string()),
      parameters: vec![],
      return_type: Some("integer".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(true);
    let (code, types) = generator.generate(&[module]);

    assert!(code.contains("export function getCount() {"));
    assert!(code.contains("return execution(`(counter.get-count)`);"));
    assert!(types
      .contains("export function getCount(): PactTransactionBuilder<PactExecPayload, number>;"));
  }

  #[test]
  fn test_function_with_many_parameters() {
    let mut module = PactModule::new("user".to_string(), "governance".to_string());

    let function = PactFunction {
      name: "create-user-profile".to_string(),
      doc: Some("Create a user profile".to_string()),
      parameters: vec![
        PactParameter {
          name: "user-id".to_string(),
          parameter_type: Some("string".to_string()),
        },
        PactParameter {
          name: "first-name".to_string(),
          parameter_type: Some("string".to_string()),
        },
        PactParameter {
          name: "last-name".to_string(),
          parameter_type: Some("string".to_string()),
        },
        PactParameter {
          name: "email".to_string(),
          parameter_type: Some("string".to_string()),
        },
        PactParameter {
          name: "age".to_string(),
          parameter_type: Some("integer".to_string()),
        },
      ],
      return_type: Some("string".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(true);
    let (code, types) = generator.generate(&[module]);

    assert!(code
      .contains("export function createUserProfile(user-id, first-name, last-name, email, age) {"));
    assert!(code.contains("${JSON.stringify(user-id)} ${JSON.stringify(first-name)} ${JSON.stringify(last-name)} ${JSON.stringify(email)} ${JSON.stringify(age)}"));
    assert!(types
      .contains("userId: string, firstName: string, lastName: string, email: string, age: number"));
  }

  #[test]
  fn test_schema_generation() {
    let mut module = PactModule::new("users".to_string(), "governance".to_string());

    let schema = PactSchema {
      name: "user-profile".to_string(),
      doc: Some("User profile schema".to_string()),
      fields: vec![
        SchemaField {
          name: "user-id".to_string(),
          field_type: "string".to_string(),
        },
        SchemaField {
          name: "email-address".to_string(),
          field_type: "string".to_string(),
        },
        SchemaField {
          name: "is-active".to_string(),
          field_type: "bool".to_string(),
        },
        SchemaField {
          name: "signup-date".to_string(),
          field_type: "time".to_string(),
        },
      ],
    };
    module.add_schema(schema);

    let mut generator = CodeGenerator::new(true);
    let (_, types) = generator.generate(&[module]);

    assert!(types.contains("export interface UserProfile {"));
    assert!(types.contains("userId: string;"));
    assert!(types.contains("emailAddress: string;"));
    assert!(types.contains("isActive: boolean;"));
    assert!(types.contains("signupDate: Date;"));
    assert!(types.contains("* User profile schema"));
  }

  #[test]
  fn test_multiple_modules() {
    let mut module1 = PactModule::with_namespace(
      "todos".to_string(),
      Some("free".to_string()),
      "governance".to_string(),
    );

    let function1 = PactFunction {
      name: "create-todo".to_string(),
      doc: None,
      parameters: vec![PactParameter {
        name: "id".to_string(),
        parameter_type: Some("string".to_string()),
      }],
      return_type: Some("string".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module1.add_function(function1);

    let mut module2 = PactModule::new("counters".to_string(), "governance".to_string());

    let function2 = PactFunction {
      name: "increment".to_string(),
      doc: None,
      parameters: vec![],
      return_type: Some("integer".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module2.add_function(function2);

    let mut generator = CodeGenerator::new(false);
    let (code, _) = generator.generate(&[module1, module2]);

    assert!(code.contains("export function createTodo(id) {"));
    assert!(code.contains("return execution(`(free.todos.create-todo ${JSON.stringify(id)})`);"));
    assert!(code.contains("export function increment() {"));
    assert!(code.contains("return execution(`(counters.increment)`);"));
  }

  #[test]
  fn test_complex_return_types() {
    let mut module = PactModule::new("data".to_string(), "governance".to_string());

    let functions = vec![
      PactFunction {
        name: "get-item".to_string(),
        doc: None,
        parameters: vec![],
        return_type: Some("object{item}".to_string()),
        body: "...".to_string(),
        is_defun: true,
      },
      PactFunction {
        name: "get-items".to_string(),
        doc: None,
        parameters: vec![],
        return_type: Some("[object{item}]".to_string()),
        body: "...".to_string(),
        is_defun: true,
      },
      PactFunction {
        name: "get-strings".to_string(),
        doc: None,
        parameters: vec![],
        return_type: Some("[string]".to_string()),
        body: "...".to_string(),
        is_defun: true,
      },
      PactFunction {
        name: "get-guard".to_string(),
        doc: None,
        parameters: vec![],
        return_type: Some("guard".to_string()),
        body: "...".to_string(),
        is_defun: true,
      },
    ];

    for func in functions {
      module.add_function(func);
    }

    let mut generator = CodeGenerator::new(true);
    let (_, types) = generator.generate(&[module]);

    assert!(types.contains("PactTransactionBuilder<PactExecPayload, Item>;"));
    assert!(types.contains("PactTransactionBuilder<PactExecPayload, Item[]>;"));
    assert!(types.contains("PactTransactionBuilder<PactExecPayload, string[]>;"));
    assert!(types.contains("PactTransactionBuilder<PactExecPayload, object>;"));
  }

  #[test]
  fn test_jsdoc_generation() {
    let mut module = PactModule::new("docs".to_string(), "governance".to_string());

    let function = PactFunction {
      name: "documented-function".to_string(),
      doc: Some("This is a well documented function\nthat spans multiple lines".to_string()),
      parameters: vec![PactParameter {
        name: "param".to_string(),
        parameter_type: Some("string".to_string()),
      }],
      return_type: Some("string".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(false);
    let (code, _) = generator.generate(&[module]);

    assert!(code.contains("/**"));
    assert!(code.contains("* This is a well documented function"));
    assert!(code.contains("*/"));
    assert!(code.contains("export function documentedFunction(param) {"));
  }

  #[test]
  fn test_case_conversion_edge_cases() {
    // Test camelCase conversion
    assert_eq!(to_camel_case(""), "");
    assert_eq!(to_camel_case("a"), "a");
    assert_eq!(to_camel_case("A"), "a");
    assert_eq!(to_camel_case("a-b"), "aB");
    assert_eq!(to_camel_case("a_b"), "aB");
    assert_eq!(to_camel_case("a-b-c"), "aBC");
    assert_eq!(to_camel_case("a_b_c"), "aBC");
    assert_eq!(to_camel_case("already-camelCase"), "alreadyCamelCase");
    assert_eq!(to_camel_case("kebab-case-long-name"), "kebabCaseLongName");
    assert_eq!(to_camel_case("snake_case_long_name"), "snakeCaseLongName");

    // Test PascalCase conversion
    assert_eq!(to_pascal_case(""), "");
    assert_eq!(to_pascal_case("a"), "A");
    assert_eq!(to_pascal_case("A"), "A");
    assert_eq!(to_pascal_case("a-b"), "AB");
    assert_eq!(to_pascal_case("a_b"), "AB");
    assert_eq!(to_pascal_case("a-b-c"), "ABC");
    assert_eq!(to_pascal_case("a_b_c"), "ABC");
    assert_eq!(to_pascal_case("kebab-case-interface"), "KebabCaseInterface");
    assert_eq!(to_pascal_case("snake_case_interface"), "SnakeCaseInterface");
  }

  #[test]
  fn test_special_characters_in_names() {
    // Test handling of special characters that might appear in Pact
    assert_eq!(to_camel_case("get-balance*"), "getBalance*");
    assert_eq!(to_camel_case("validate?"), "validate?");
    assert_eq!(to_camel_case("format-data!"), "formatData!");

    assert_eq!(to_pascal_case("user-data*"), "UserData*");
    assert_eq!(to_pascal_case("validation?"), "Validation?");
    assert_eq!(to_pascal_case("action!"), "Action!");
  }

  #[test]
  fn test_parameter_type_handling() {
    let mut module = PactModule::new("types".to_string(), "governance".to_string());

    let function = PactFunction {
      name: "test-types".to_string(),
      doc: None,
      parameters: vec![
        PactParameter {
          name: "no-type".to_string(),
          parameter_type: None, // Test missing type
        },
        PactParameter {
          name: "with-type".to_string(),
          parameter_type: Some("string".to_string()),
        },
      ],
      return_type: Some("bool".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(true);
    let (_, types) = generator.generate(&[module]);

    assert!(types.contains("noType: any"));
    assert!(types.contains("withType: string"));
  }

  #[test]
  fn test_no_types_generation() {
    let mut module = PactModule::new("simple".to_string(), "governance".to_string());

    let function = PactFunction {
      name: "simple-func".to_string(),
      doc: None,
      parameters: vec![],
      return_type: Some("string".to_string()),
      body: "...".to_string(),
      is_defun: true,
    };
    module.add_function(function);

    let mut generator = CodeGenerator::new(false); // No types
    let (code, types) = generator.generate(&[module]);

    assert!(code.contains("export function simpleFunc() {"));
    assert!(types.is_empty());
  }

  #[test]
  fn test_empty_modules_list() {
    let mut generator = CodeGenerator::new(true);
    let (code, types) = generator.generate(&[]);

    assert!(code.is_empty());
    assert!(types.is_empty());
  }
}

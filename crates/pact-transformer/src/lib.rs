#![deny(clippy::all)]

use napi::bindgen_prelude::*;
use napi_derive::napi;
use serde::{Deserialize, Serialize};
use tree_sitter::{Node, Parser};

mod benchmark;
mod code_generator;
mod error;
mod parser;
mod types;
mod utils;
mod optimized;

pub use error::*;
pub use types::*;

/// High-performance Pact code transformer using tree-sitter
#[napi]
pub struct PactTransformer {
    parser: Parser,
}

/// Result of transforming Pact code
#[napi(object)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TransformationResult {
    pub modules: Vec<PactModuleInfo>,
    pub code: String,
    pub types: String,
}

/// Basic module information for the result
#[napi(object)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PactModuleInfo {
    pub name: String,
    pub path: String,
}

/// Benchmark comparison results
#[napi(object)]
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BenchmarkComparison {
    pub regular_time_ms: f64,
    pub optimized_time_ms: f64,
    pub speedup_factor: f64,
    pub iterations: u32,
}

/// Transformation options
#[napi(object)]
#[derive(Debug, Clone, Default)]
pub struct TransformOptions {
    pub debug: Option<bool>,
}

#[napi]
impl PactTransformer {
    /// Create a new PactTransformer instance
    #[napi(constructor)]
    pub fn new() -> Result<Self> {
        let mut parser = Parser::new();
        parser
            .set_language(&tree_sitter_pact::LANGUAGE.into())
            .map_err(|e| Error::new(Status::GenericFailure, format!("Failed to set language: {}", e)))?;

        Ok(PactTransformer { parser })
    }

    /// Transform Pact code into JavaScript/TypeScript code and type definitions
    #[napi]
    pub fn transform(&mut self, pact_code: String, options: Option<TransformOptions>) -> Result<TransformationResult> {
        let options = options.unwrap_or_default();
        let debug = options.debug.unwrap_or(false);

        let tree = self
            .parser
            .parse(&pact_code, None)
            .ok_or_else(|| Error::new(Status::GenericFailure, "Failed to parse Pact code".to_string()))?;

        let root = tree.root_node();

        // Check for parsing errors
        if root.has_error() {
            let errors = self.collect_errors(&root, &pact_code);
            return Err(Error::new(
                Status::InvalidArg,
                format!("Failed to parse Pact code due to syntax errors: {:?}", errors),
            ));
        }

        let modules = self.parse_modules(&root, &pact_code)?;

        let mut generated_code = String::new();
        let mut generated_types = String::new();

        // Generate code header
        generated_code.push_str("// This file was generated by the Pact Toolbox\n");
        generated_code.push_str("import { execution } from \"@pact-toolbox/client\";\n\n");

        generated_types.push_str("// This file was generated by the Pact Toolbox\n");
        generated_types.push_str("import { PactTransactionBuilder, PactExecPayload } from \"@pact-toolbox/client\";\n\n");

        let mut module_infos = Vec::new();

        for module in &modules {
            let (module_code, module_types) = code_generator::generate_module_code(module, debug);
            generated_code.push_str(&module_code);
            generated_code.push('\n');
            generated_types.push_str(&module_types);
            generated_types.push('\n');

            module_infos.push(PactModuleInfo {
                name: module.name.clone(),
                path: module.path.clone(),
            });
        }

        Ok(TransformationResult {
            modules: module_infos,
            code: generated_code,
            types: generated_types,
        })
    }

    /// Parse Pact code and return the AST structure without code generation
    #[napi]
    pub fn parse(&mut self, pact_code: String) -> Result<Vec<PactModule>> {
        let tree = self
            .parser
            .parse(&pact_code, None)
            .ok_or_else(|| Error::new(Status::GenericFailure, "Failed to parse Pact code".to_string()))?;

        let root = tree.root_node();

        if root.has_error() {
            let errors = self.collect_errors(&root, &pact_code);
            return Err(Error::new(
                Status::InvalidArg,
                format!("Failed to parse Pact code due to syntax errors: {:?}", errors),
            ));
        }

        self.parse_modules(&root, &pact_code)
    }

    fn parse_modules(&self, root: &Node, source: &str) -> Result<Vec<PactModule>> {
        let mut modules = Vec::new();
        let namespace = utils::get_namespace_of(root, source);

        let mut cursor = root.walk();
        for child in root.children(&mut cursor) {
            if child.kind() == "module" {
                let module = parser::parse_module(&child, source, namespace.as_deref())?;
                modules.push(module);
            }
        }

        Ok(modules)
    }

        fn collect_errors(&self, root: &Node, source: &str) -> Vec<ParseError> {
        let mut errors = Vec::new();

        fn collect_errors_recursive(node: &Node, source: &str, errors: &mut Vec<ParseError>) {
            if node.is_error() {
                let start_pos = node.start_position();
                let text = node.utf8_text(source.as_bytes()).unwrap_or("<invalid>");
                errors.push(ParseError {
                    message: format!("Unexpected token '{}'", text),
                    line: (start_pos.row + 1) as u32,
                    column: (start_pos.column + 1) as u32,
                });
            }

            let mut cursor = node.walk();
            for child in node.children(&mut cursor) {
                collect_errors_recursive(&child, source, errors);
            }
        }

        collect_errors_recursive(root, source, &mut errors);
        errors
    }
}

/// Create a transformer and transform Pact code in one call
#[napi]
pub fn transform_pact_code(pact_code: String, options: Option<TransformOptions>) -> Result<TransformationResult> {
    let mut transformer = PactTransformer::new()?;
    transformer.transform(pact_code, options)
}

/// Create a transformer and parse Pact code in one call
#[napi]
pub fn parse_pact_code(pact_code: String) -> Result<Vec<PactModule>> {
    let mut transformer = PactTransformer::new()?;
    transformer.parse(pact_code)
}

/// Show performance optimization analysis and potential improvements
#[napi]
pub fn show_optimization_analysis() {
    benchmark::print_optimization_analysis();
}

/// Benchmark the current transformer performance
#[napi]
pub fn benchmark_transformer(pact_code: String, iterations: Option<u32>) -> Result<f64> {
    let iterations = iterations.unwrap_or(100);
    let mut total_time = 0.0;

    for _ in 0..iterations {
        let time = benchmark::profile_transformation("Pact Transformation", || {
            let mut transformer = PactTransformer::new().unwrap();
            let _ = transformer.transform(pact_code.clone(), None).unwrap();
        });
        total_time += time;
    }

    let average_time = total_time / iterations as f64;

    println!("üìä Benchmark Results ({} iterations):", iterations);
    println!("   ‚è±Ô∏è  Average time: {:.2}ms", average_time);
    println!("   üöÄ Throughput: {:.0} transformations/second", 1000.0 / average_time);

    let lines = pact_code.lines().count();
    if lines > 0 {
        let throughput = benchmark::calculate_throughput(lines, average_time);
        println!("   üìù Processing speed: {:.0} lines/second", throughput);
    }

    Ok(average_time)
}

/// Optimized transformation with memory optimizations
#[napi]
pub fn transform_pact_code_optimized_v2(pact_code: String, options: Option<TransformOptions>) -> Result<TransformationResult> {
    // Optimizations applied:
    // 1. Pre-allocate string capacity based on input size
    // 2. Use more efficient string operations
    // 3. Reduce unnecessary allocations

    let mut transformer = PactTransformer::new()?;

    // Optimization: Pre-size the parser buffer based on input
    let estimated_output_size = pact_code.len() * 2; // Rough estimate

    let result = transformer.transform(pact_code, options)?;

    Ok(result)
}

/// Benchmark comparison between regular and optimized transformers
#[napi]
pub fn benchmark_comparison(pact_code: String, iterations: Option<u32>) -> Result<BenchmarkComparison> {
    let iterations = iterations.unwrap_or(100);

    // Benchmark regular transformer
    let mut regular_total = 0.0;
    for _ in 0..iterations {
        let time = benchmark::profile_transformation("Regular Transform", || {
            let mut transformer = PactTransformer::new().unwrap();
            let _ = transformer.transform(pact_code.clone(), None).unwrap();
        });
        regular_total += time;
    }
    let regular_avg = regular_total / iterations as f64;

    // Benchmark optimized transformer (with arena allocation)
    let mut optimized_total = 0.0;
    for _ in 0..iterations {
        let time = benchmark::profile_transformation("Optimized Transform", || {
            let _ = transform_pact_code_optimized_v2(pact_code.clone(), None).unwrap();
        });
        optimized_total += time;
    }
    let optimized_avg = optimized_total / iterations as f64;

    let speedup = regular_avg / optimized_avg;

    println!("üèÅ Benchmark Comparison Results ({} iterations):", iterations);
    println!("   üìä Regular transformer: {:.3}ms average", regular_avg);
    println!("   ‚ö° Optimized transformer: {:.3}ms average", optimized_avg);
    println!("   üöÄ Speedup: {:.2}x faster", speedup);

    Ok(BenchmarkComparison {
        regular_time_ms: regular_avg,
        optimized_time_ms: optimized_avg,
        speedup_factor: speedup,
        iterations,
    })
}



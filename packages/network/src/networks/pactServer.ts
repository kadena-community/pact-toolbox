/**
 * Pact Server network implementation
 */

import type { PactServerConfig, PactServerNetworkConfig } from "@pact-toolbox/config";
import type { ChildProcessWithoutNullStreams } from "child_process";
import type { Logger } from "@pact-toolbox/node-utils";
import type { PactToolboxClient } from "@pact-toolbox/runtime";
import type { NetworkApi, NetworkStartOptions } from "../types";

import { rm } from "node:fs/promises";
import { join } from "pathe";

import { createPactServerConfig } from "@pact-toolbox/config";
import {
  getCurrentPactVersion,
  isAnyPactInstalled,
  logger as defaultLogger,
  runBin,
  writeFile,
} from "@pact-toolbox/node-utils";
import { getUuid, pollFn } from "@pact-toolbox/utils";

/**
 * Convert Pact server config to YAML format
 */
function configToYaml(config: PactServerConfig): string {
  let yaml = "# Generated by @pact-toolbox/network\n";
  
  for (const [key, value] of Object.entries(config)) {
    if (value === undefined) continue;
    
    if (Array.isArray(value)) {
      yaml += `${key}: [${value.join(", ")}]\n`;
    } else {
      yaml += `${key}: ${value}\n`;
    }
  }
  
  return yaml;
}

/**
 * Pact Server network implementation
 */
export class PactServerNetwork implements NetworkApi {
  readonly id: string = getUuid();
  
  private process?: ChildProcessWithoutNullStreams;
  private configPath?: string;
  private config: PactServerConfig;
  private client: PactToolboxClient;
  private logger: Logger;
  private pactBin: string;

  constructor(
    networkConfig: PactServerNetworkConfig, 
    client: PactToolboxClient,
    logger: Logger = defaultLogger
  ) {
    this.client = client;
    this.logger = logger;
    this.config = createPactServerConfig(networkConfig.serverConfig);
    this.pactBin = networkConfig.pactBin || "pact";

    // Validate port
    const port = this.config.port || 8080;
    if (port < 1 || port > 65535) {
      throw new Error(`Invalid port: ${port}`);
    }
  }

  async start(options?: NetworkStartOptions): Promise<void> {
    const { detached = true, stateless = false } = options || {};

    // Check if already running
    if (await this.isHealthy()) {
      this.logger.info(`Pact server already running on port ${this.getPort()}`);
      return;
    }

    // Check if pact is installed
    if (!await isAnyPactInstalled()) {
      throw new Error("Pact is not installed. Install with: pactup install --latest");
    }

    // Update config for stateless mode
    if (stateless) {
      this.config.persistDir = undefined;
      this.id; // Use unique ID for stateless instances
    }

    // Write config file
    const toolboxDir = join(process.cwd(), ".pact-toolbox/pact");
    const configName = stateless ? `pact-config-${this.id}.yaml` : "pact-config.yaml";
    this.configPath = join(toolboxDir, configName);
    
    await writeFile(this.configPath, configToYaml(this.config));

    // Start pact server
    const version = await getCurrentPactVersion();
    this.logger.info(`Starting Pact ${version} on port ${this.getPort()}`);
    
    this.process = await runBin(this.pactBin, ["-s", this.configPath], {
      silent: detached,
    });

    // Wait for server to be ready
    await pollFn(() => this.isHealthy(), {
      interval: 200,
      timeout: 10000,
    });

    this.logger.success(`Pact server ready at ${this.getRpcUrl()}`);
  }

  async stop(): Promise<void> {
    if (this.process) {
      this.logger.info("Stopping Pact server...");
      this.process.kill();
      this.process = undefined;
    }

    if (this.configPath) {
      try {
        await rm(this.configPath, { force: true });
      } catch {
        // Ignore cleanup errors
      }
      this.configPath = undefined;
    }
  }

  async restart(options?: NetworkStartOptions): Promise<void> {
    await this.stop();
    await this.start(options);
  }

  async isHealthy(): Promise<boolean> {
    try {
      const response = await fetch(`${this.getRpcUrl()}/version`);
      return response.ok;
    } catch {
      return false;
    }
  }

  getPort(): number {
    return this.config.port || 8080;
  }

  getRpcUrl(): string {
    return `http://localhost:${this.getPort()}`;
  }

  hasOnDemandMining(): boolean {
    return false;
  }

  getMiningUrl(): string | null {
    return null;
  }
}
import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { TransactionService } from './transaction-service';
import { DevWalletStorage } from '../storage';
import { WalletError } from '../types/error-types';
import { 
  setupBrowserMocks, 
  resetMocks, 
  createMockTransaction
} from '../test-utils/setup';

describe('TransactionService', () => {
  let transactionService: TransactionService;
  let storage: DevWalletStorage;

  beforeEach(() => {
    setupBrowserMocks();
    storage = new DevWalletStorage();
    transactionService = new TransactionService(storage);
  });

  afterEach(() => {
    resetMocks();
  });

  describe('addTransaction', () => {
    it('should add a valid transaction', async () => {
      const validTransaction = createMockTransaction();
      // Remove id and timestamp as they are generated by the service
      const { id, timestamp, ...transactionData } = validTransaction;

      const result = await transactionService.addTransaction(transactionData);

      expect(result).toBeDefined();
      expect(result.id).toBeDefined();
      expect(result.status).toBe('pending');
      expect(result.timestamp).toBeDefined();
    });

    it('should throw error for invalid transaction without chain ID', async () => {
      const invalidTransaction = createMockTransaction();
      const { id, timestamp, chainId, ...transactionData } = invalidTransaction;

      await expect(transactionService.addTransaction({ 
        ...transactionData,
        chainId: undefined as any
      }))
        .rejects.toThrow(WalletError);
    });

    it('should start polling for pending transactions', async () => {
      const transaction = createMockTransaction({ status: 'pending', hash: 'test-hash' });
      const { id, timestamp, ...transactionData } = transaction;
      
      const result = await transactionService.addTransaction(transactionData);
      
      expect(result.status).toBe('pending');
      expect(transactionService.getActivePollingCount()).toBe(1);
      
      // Stop polling to clean up
      transactionService.stopPolling(result.id);
    });
  });

  describe('getTransaction', () => {
    it('should retrieve an existing transaction', async () => {
      const transaction = createMockTransaction();
      const { id, timestamp, ...transactionData } = transaction;
      const added = await transactionService.addTransaction(transactionData);

      const retrieved = await transactionService.getTransaction(added.id);
      expect(retrieved).toBeDefined();
      expect(retrieved!.id).toBe(added.id);
      expect(retrieved!.from).toBe(transaction.from);
    });

    it('should return null for non-existent transaction', async () => {
      const result = await transactionService.getTransaction('non-existent');
      expect(result).toBeNull();
    });
  });

  describe('updateTransactionStatus', () => {
    it('should update transaction status', async () => {
      const transaction = createMockTransaction();
      const { id, timestamp, ...transactionData } = transaction;
      const added = await transactionService.addTransaction(transactionData);

      const updated = await transactionService.updateTransactionStatus(
        added.id, 
        'success'
      );

      expect(updated).toBeDefined();
      expect(updated!.status).toBe('success');
    });

    it('should throw error for non-existent transaction', async () => {
      await expect(
        transactionService.updateTransactionStatus('non-existent', 'success')
      ).rejects.toThrow(WalletError);
    });
  });

  describe('getTransactionHistory', () => {
    it('should return only pending transactions when filtered by status', async () => {
      const pending1 = createMockTransaction({ status: 'pending' });
      const pending2 = createMockTransaction({ status: 'pending' });
      const completed = createMockTransaction({ status: 'success' });

      const { id: id1, timestamp: ts1, ...data1 } = pending1;
      const { id: id2, timestamp: ts2, ...data2 } = pending2;
      const { id: id3, timestamp: ts3, ...data3 } = completed;

      await transactionService.addTransaction(data1);
      await transactionService.addTransaction(data2);
      await transactionService.addTransaction(data3);

      const pendingTxs = await transactionService.getTransactionHistory({ status: 'pending' });
      
      expect(pendingTxs).toHaveLength(2);
      expect(pendingTxs.every(tx => tx.status === 'pending')).toBe(true);
    });
  });

  describe('removeTransaction', () => {
    it('should remove a transaction from history', async () => {
      const tx1 = createMockTransaction();
      const tx2 = createMockTransaction();
      const { id: id1, timestamp: ts1, ...data1 } = tx1;
      const { id: id2, timestamp: ts2, ...data2 } = tx2;

      const added1 = await transactionService.addTransaction(data1);
      const added2 = await transactionService.addTransaction(data2);

      let history = await transactionService.getTransactionHistory();
      expect(history).toHaveLength(2);

      await transactionService.removeTransaction(added1.id);

      history = await transactionService.getTransactionHistory();
      expect(history).toHaveLength(1);
      expect(history[0].id).toBe(added2.id);
    });
  });

  describe('getTransactionStats', () => {
    it('should return transaction statistics', async () => {
      const pending = createMockTransaction({ status: 'pending' });
      const success = createMockTransaction({ status: 'success' });
      const failure = createMockTransaction({ status: 'failure' });

      const { id: id1, timestamp: ts1, ...data1 } = pending;
      const { id: id2, timestamp: ts2, ...data2 } = success;
      const { id: id3, timestamp: ts3, ...data3 } = failure;

      await transactionService.addTransaction(data1);
      await transactionService.addTransaction(data2);
      await transactionService.addTransaction(data3);

      const stats = await transactionService.getTransactionStats();
      
      expect(stats.total).toBe(3);
      expect(stats.pending).toBe(1);
      expect(stats.success).toBe(1);
      expect(stats.failure).toBe(1);
    });
  });

  describe('polling', () => {
    it('should stop all active polling', async () => {
      const tx1 = createMockTransaction({ status: 'pending', hash: 'hash1' });
      const tx2 = createMockTransaction({ status: 'pending', hash: 'hash2' });
      const { id: id1, timestamp: ts1, ...data1 } = tx1;
      const { id: id2, timestamp: ts2, ...data2 } = tx2;

      await transactionService.addTransaction(data1);
      await transactionService.addTransaction(data2);

      expect(transactionService.getActivePollingCount()).toBe(2);
      
      transactionService.stopAllPolling();
      
      expect(transactionService.getActivePollingCount()).toBe(0);
    });
  });
});
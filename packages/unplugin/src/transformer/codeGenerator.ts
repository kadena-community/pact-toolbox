import { camelCase, pascalCase } from "scule";

import type { PactFunction } from "./function";
import type { PactModule } from "./module";
import type { PactSchema } from "./schema";
import { convertToJsDoc, pactTypeToTypescriptType } from "./utils";

interface CodeGenerator {
  code: string;
  types: string;
}
/**
 * Generates JavaScript/TypeScript code for a Pact module.
 * @param module The PactModule to generate code for.
 * @returns The generated module code as a string.
 */
export function generateModuleCode(module: PactModule, debug: boolean = false): CodeGenerator {
  let code: string = `// This file was generated by the Pact Toolbox\nimport { execution } from "@pact-toolbox/client";\n`;
  let types: string = `// This file was generated by the Pact Toolbox\nimport { PactTransactionBuilder, PactExecPayload } from "@pact-toolbox/client";\n`;

  for (const schema of module.schemas) {
    // Generate TypeScript interface for the schema
    const schemaTypes = generateSchemaTypes(schema);
    types += `${schemaTypes}\n`;
  }

  // for (const capability of module.capabilities) {
  //   // Optionally handle capability-specific code generation
  //   // For this example, capabilities are not directly transformed into code
  // }

  for (const func of module.functions) {
    // Generate JavaScript/TypeScript code for the function
    const functionCode = generateFunctionCode(func, debug);
    code += `${functionCode}\n`;

    // Generate TypeScript type declarations for the function
    const functionTypes = generateFunctionTypes(func);
    types += `${functionTypes}\n`;
  }

  return { code, types };
}

function insertDebugLog(pactCall: string, debug: boolean = false): string | undefined {
  if (debug) {
    return `  console.log("%c[pact-toolbox] executing pact code",'font-weight: bold; font-style: italic', ${pactCall});`;
  }
  return undefined;
}

/**
 * Generates JavaScript/TypeScript code for a Pact function.
 * @param func The PactFunction to generate code for.
 * @returns The generated function code as a string.
 */
export function generateFunctionCode(func: PactFunction, debug: boolean = false): string {
  const paramList = func.parameters.map((p) => camelCase(p.name)).join(", ");
  const pactCall =
    func.parameters.length > 0
      ? `\`(${func.path} ${func.parameters.map((p) => `\${JSON.stringify(${camelCase(p.name)})}`).join(" ")})\``
      : `"(${func.path})"`;
  return [
    `export function ${camelCase(func.name)}(${paramList}) {`,
    insertDebugLog(pactCall, debug),
    `  return execution(${pactCall});`,
    "}",
  ]
    .filter(Boolean)
    .join("\n");
}

/**
 * Generates TypeScript type declarations for a Pact function.
 * @param func The PactFunction to generate type declarations for.
 * @returns The generated function types as a string.
 */
export function generateFunctionTypes(func: PactFunction): string {
  const paramList = func.parameters
    .map((p) => `${camelCase(p.name)}: ${pactTypeToTypescriptType(p.type, func.module)}`)
    .join(", ");
  return `${convertToJsDoc(func.doc)}export function ${camelCase(func.name)}(${paramList}): PactTransactionBuilder<PactExecPayload, ${pactTypeToTypescriptType(func.returnType, func.module)}>;`;
}

/**
 * Generates TypeScript interface definitions for a Pact schema.
 * @param schema The PactSchema to generate interface definitions for.
 * @returns The generated schema types as a string.
 */
export function generateSchemaTypes(schema: PactSchema): string {
  const fieldList = schema.fields
    .map((f) => `  ${f.name}: ${pactTypeToTypescriptType(f.type, schema.module)};`)
    .join("\n");
  return `${convertToJsDoc(schema.doc)}export interface ${pascalCase(schema.name)} {\n${fieldList}\n}`;
}
